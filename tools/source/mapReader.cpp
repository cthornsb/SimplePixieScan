#include <iostream>
#include <fstream>
#include <string>
#include <time.h>

#include "TFile.h"
#include "TTree.h"
#include "TObject.h"
#include "TCollection.h" // TIter class

#include "simpleTool.hpp"

class mapReader : public simpleTool {
  private:
	int startMod;
	int stopMod;

	int method;

	bool process(std::ofstream &file_, std::string dirpath_);

	bool processMap(std::ofstream &file_);

	bool processTime(std::ofstream &file_);

	bool processEnergy(std::ofstream &file_);

	bool processPosition(std::ofstream &file_);

  public:
	mapReader() : simpleTool(), startMod(0), stopMod(12), method(0) { }
	
	void addOptions();
	
	bool processArgs();
	
	int execute(int argc, char *argv[]);
};

bool mapReader::process(std::ofstream &file_, std::string dirpath_){
	// Load the currect directory.
	TDirectory *dir = infile->GetDirectory(dirpath_.c_str());

	// Failed to load directory.
	if(!dir) return false;

	// Get list of map entries.
	TIter iter(dir->GetListOfKeys());

	while(true){
		TObject *obj = iter();
		if(!obj) break;

		// Write the map entry to the file.
		file_ << obj->GetName() << std::endl;
	}

	return true;
}

bool mapReader::processMap(std::ofstream &file_){
	if(!file_.good()) return false;

	const int padding = 2;

	const std::string pathPrefix = "/map/mod";

	// Get the current time.
	time_t now = time(0);

	// Append a header to the output map file.
	file_ << "# SimplePixieScan map file\n";
	file_ << "# Setup an experiment by defining different detector types on different pixie\n";
	file_ << "# channel pairs (mod chan). All values MUST be separated by spaces. Currently\n";
	file_ << "# the only valid detector tag is \"start\". arg1, arg2, and so on may be used\n";
	file_ << "# to set fitting and cfd parameters. For fitting, arg1=beta and arg2=gamma. For\n";
	file_ << "# CFD arg1=F.\n";
	file_ << "#  You may define multiple channels using \":\" e.g. 2:5.\n";
	file_ << "#  You may define only even channels in a range using \"e\" e.g. 0:15:e\n";
	file_ << "#  You may define only odd channels in a range using \"o\" e.g. 0:15:o\n";
	file_ << "# Generated by mapReader on " << ctime(&now);
	file_ << "# Input root file: " << input_filename << std::endl;
	file_ << "#mod chan type:subtype:tag arg1 arg2 ... argN\n";	

	for(int mod = startMod; mod <= stopMod; mod++){
		std::stringstream stream;
		stream << mod;
	
		// Get the root path of the current module's map.
		std::string currentName = pathPrefix;
		if(stream.str().length() < (unsigned int)padding)
			currentName += std::string(padding - stream.str().length(), '0');
		currentName += stream.str() + "/";

		if(process(file_, currentName.c_str())) std::cout << " Read entries from module " << mod << std::endl;
	}

	return true;
}

bool mapReader::processTime(std::ofstream &file_){
	if(!file_.good()) return false;

	// Get the current time.
	time_t now = time(0);

	// Append a header to the output map file.
	file_ << "# SimplePixieScan time.cal file\n";
	file_ << "# Set the time offset for a given scan channel (16*m + c, where m is the module\n";
	file_ << "# and c is the channel) relative to the start detector. The following operation\n";
	file_ << "# is applied, T = T' - t0 where T is the calibrated time, T' is the uncalibrated\n";
	file_ << "# time, and t0 is given below (all in ns).\n";
	file_ << "#  Generated by mapReader on " << ctime(&now);
	file_ << "#  Input root file: " << input_filename << std::endl;
	file_ << "#id	t0(ns)\n";

	return process(file_, "/calib/time");
}

bool mapReader::processEnergy(std::ofstream &file_){
	if(!file_.good()) return false;

	// Get the current time.
	time_t now = time(0);

	// Append a header to the output map file.
	file_ << "# SimplePixieScan energy.cal file\n";
	file_ << "# Set the energy calibration for a given scan channel (16*m + c, where m is the module\n";
	file_ << "# and c is the channel) using the nth order polynomial p0 + p1*x + ... + pn*x^n.\n";
	file_ << "#  Generated by mapReader on " << ctime(&now);
	file_ << "#  Input root file: " << input_filename << std::endl;
	file_ << "#id	p0	p1	...	pn\n";

	return process(file_, "/calib/energy");
}

bool mapReader::processPosition(std::ofstream &file_){
	if(!file_.good()) return false;

	// Get the current time.
	time_t now = time(0);

	// Append a header to the output map file.
	file_ << "# SimplePixieScan position.cal file\n";
	file_ << "# Set the detector position for a given scan channel (16*m + c, where m is the module\n";
	file_ << "# and c is the channel) in spherical coordinates.\n";
	file_ << "#  Generated by mapReader on " << ctime(&now);
	file_ << "#  Input root file: " << input_filename << std::endl;
	file_ << "#id	r0(m)	theta(deg)	phi(deg)\n";

	return process(file_, "/calib/position");
}

void mapReader::addOptions(){
	addOption(optionExt("modules", required_argument, NULL, 'm', "<start:stop>", "Specify start and stop module as a pair e.g. \"3:7\" (default is 0:12)."), userOpts, optstr);
	addOption(optionExt("method", required_argument, NULL, 'M', "<method>", "Specify file operation [0=\"map.dat\", 1=\"time.cal\", 2=\"energy.cal\", 3=\"position.cal\"]."), userOpts, optstr);
}

bool mapReader::processArgs(){
	if(userOpts.at(0).active){ // --modules
		std::string userID = userOpts.at(0).argument;
		if(userID.find(':') != std::string::npos){
			startMod = strtol(userID.substr(0, userID.find_first_of(':')).c_str(), NULL, 0);
			stopMod = strtol(userID.substr(userID.find_first_of(':')+1).c_str(), NULL, 0);
		}
		else{
			std::cout << " Error: Invalid module range specification (" << userID << ")!\n";
			std::cout << "  Module range must be given as pair delimited with ':' e.g. \"3:7\".\n";
			return false;
		}

		if(startMod < 0){
			std::cout << " Error: Invalid start module specification (" << startMod << ")!\n";
			return false;
		}
		if(stopMod < 0){
			std::cout << " Error: Invalid stop module specification (" << stopMod << ")!\n";
			return false;
		}
	}
	else if(userOpts.at(1).active){
		method = strtol(userOpts.at(1).argument.c_str(), NULL, 0);
		if(method < 0 || method > 3){
			std::cout << " Error: Invalid file operation (" << method << ")!\n";
			return false;
		}
	}

	return true;
}

int mapReader::execute(int argc, char *argv[]){
	if(!setup(argc, argv))
		return 0;	

	if(input_filename.empty()){
		std::cout << " Error: Input filename not specified!\n";
		return 1;
	}

	if(output_filename.empty()){
		if(method == 0) output_filename = "map.dat";
		else if(method == 1) output_filename = "time.cal";
		else if(method == 2) output_filename = "energy.cal";
		else if(method == 3) output_filename = "position.cal";
	}

	if(!openInputFile()){
		std::cout << " Error: Failed to load input file \"" << input_filename << "\".\n";
		return 2;
	}

	std::ofstream ofile(output_filename.c_str());
	if(!ofile.good()){
		std::cout << " Error: Failed to load output file \"" << output_filename << "\".\n";
		return 3;
	}

	if(method == 0) processMap(ofile);
	else if(method == 1) processTime(ofile);
	else if(method == 2) processEnergy(ofile);
	else if(method == 3) processPosition(ofile);

	ofile.close();

	return 0;
}

int main(int argc, char *argv[]){
	mapReader obj;
	
	return obj.execute(argc, argv);
}
